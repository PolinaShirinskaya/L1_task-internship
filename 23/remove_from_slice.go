// Удалить i-ый элемент из слайса.

package main

import "fmt"


// удаление с сохранением порядка и копированием среза
/*
__Плюсы:
Сохраняет порядок оставшихся элементов, что важно, если порядок элементов имеет значение.
Не создает новый срез, что может быть полезно в случае больших срезов, чтобы избежать перераспределения памяти.

__Минусы:
Требует копирования всех элементов, следующих за удаляемым, что может быть замедлением для больших срезов.*/
func removeCopy(slice []int, index int) []int {
	// [3 4 5] + [4 5]
	copy(slice[index:], slice[index+1:]) // [1 2 4 5 5]
	// уменьшаем
	slice = slice[:len(slice)-1] // [1 2 4 5]
	return slice
}




// удаление с сохранением порядка и использованием append
/*
__Плюсы:
Сохраняет порядок оставшихся элементов.

__Минусы:
Создает новый срез, что может быть неэффективным в случае больших срезов из-за выделения новой памяти и копирования элементов.*/
func removeAppend(slice []int, index int) []int {
	return append(slice[:index], slice[index+1:]...)
}



// удаление без сохранения порядка
/*
__Плюсы:
Быстрый, так как он просто заменяет удаляемый элемент последним элементом и затем уменьшает длину среза.
Не требует копирования элементов, следующих за удаляемым.

__Минусы:
Не сохраняет порядок оставшихся элементов, что может быть проблемой, если порядок важен.*/
func removeNoOrder(slice []int, index int) []int {

	// копируем элемент с нужным индексом последним элементом
	slice[index] = slice[len(slice)-1] //[1 2 5 4 5]

	// удаляем последний элемент из среза
	slice = slice[:len(slice)-1] // [1 2 5 4]

	return slice
}

func main() {
    fmt.Println("___Удаление элемента без сохранения последовательности")
    slice1 := []int{1, 2, 3, 4, 5}
	fmt.Println("Изначально: ", slice1)
    indexToRemove1 := 2
    slice1 = removeNoOrder(slice1, indexToRemove1)
	fmt.Printf("После удаления: %v\n\n", slice1)


	fmt.Println("___Удаление элемента c сохранение последовательности и копированием")
    slice2 := []int{1, 2, 3, 4, 5}
	fmt.Println("Изначально: ", slice2)
    indexToRemove2 := 2
    slice2 = removeCopy(slice2, indexToRemove2)
	fmt.Printf("После удаления: %v\n\n", slice2)

	fmt.Println("___Удаление элемента c сохранение последовательности и append")
    slice3 := []int{1, 2, 3, 4, 5}
	fmt.Println("Изначально: ", slice3)
    indexToRemove3 := 2
    slice3 = removeCopy(slice3, indexToRemove3)
	fmt.Printf("После удаления: %v\n\n", slice3)

}
