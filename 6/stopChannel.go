// Реализовать все возможные способы остановки выполнения горутины.

/* Использование канала для сигнала о завершении:
 в этом способе используется канал для передачи сигнала о завершении горутины. 
 Когда главная функция или другая горутина хочет завершить выполнение данной горутины, 
 она отправляет значение в канал, и горутина завершает выполнение, после принятие этого значения из канала.*/

package main

import (
    "fmt"
    "time"
)

func myGoroutine(stopCh chan struct{}) {
    for {
        select {
		// Для отслеживания сигнаала завершения
        case <-stopCh:
			fmt.Println("Сигнал о закрытии канала")
            fmt.Println("Завершение...")
            return
        default:
            fmt.Println("MyGorutine работает")
            time.Sleep(time.Second)
        }
    }
}

func main() {
    // канал-сигнал для синхронизации
    // пустая структура занимает нулевой байт памяти 
    // и позволяет создавать каналы, 
    // которые могут передавать только сигналы о событиях
    stopCh := make(chan struct{})
    go myGoroutine(stopCh)

    // Время для работы горутины
    time.Sleep(5 * time.Second)

    // Остановка работы горутины, отпрвка стгнала о завершении
    close(stopCh)

	// Время для отслеживания завершения горутины
    time.Sleep(2 * time.Second)
    fmt.Println("Основная горутина main завершает выполнение.")
}
